---
title: "Hooks Revisited: useMemo"
date: "2020-03-24"
published: false
tags:
  - "react"
  - "hooks"
  - "javascript"
---

import { Link } from "gatsby"

Up until this point in <Link to="/hooks-revisited">the series</Link>, I have been generally familiar with the hooks we've covered and have used them before at work. It wasn't until I recently started working in a new codebase that I came across [`useMemo`](https://reactjs.org/docs/hooks-reference.html#usememo). Not understanding how it worked or how to debug it was a large part of why I chose to write this series in the first place.

### What is "memoization"?

If you look at the React docs, they say that the `useMemo` hook "returns a memoized value". [Memoization](https://en.wikipedia.org/wiki/Memoization) was **not** a term I was familiar with when I first read it, so don't worry if you haven't heard of it either. We're in the same boat!

Essentially, it is an optimization strategy that returns cached values from functions that have previously been invoked with the same arguments. In other words, instead of recalculating a value functions will return a cached value. This is useful when you have functions doing memory intensive calculations and want to minimize how often they're invoked

Here's my mental model for how this works:

```javascript
// Value must be calculated
add(1, 2)

// Value must be calculated
add(3, 4)

// Cached value returned
add(1, 2)
```

### Anatomy of useMemo

As mentioned, the `useMemo` hook returns a "memoized value" and takes two arguments:

1. A function
2. A dependency array

Here's an example of how it looks directly from the React docs:

```javascript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b])
```

If you have read my articles on <Link to="/hooks-useeffect">useEffect</Link> and <Link to="/hooks-uselayouteffect">useLayoutEffect</Link>, you'll probably recognize this function signature. Just like those hooks, `useMemo` executes the logic inside the function passed to it **only** when one of the values in the dependency array changes. If no array is passed, `useMemo` will re-calculate its return value on **every** render.

The difference here is that `useMemo` is not intended to cause side effects -- those should be handled in the appropriately named `useEffect` or `useLayoutEffect` hooks. `useMemo` simply calculates and returns a value based on the function and dependency array passed to it and helps with handling expensive computations that may cause your application to perform poorly.

### Optimization

According to the React docs, `useMemo` is meant to be a **performance optimization**. They suggest you get your code to work without `useMemo` and implement it after the fact to avoid recalculating expensive values when a cached value would be more performant.

One thing to note, however, is that you can't really guarantee that `useMemo` will return a cached value when expected. Read the following sentence carefully:

> In the future, React may choose to “forget” some previously memoized values and recalculate them on next render, e.g. to free memory for offscreen components. [[React docs](https://reactjs.org/docs/hooks-reference.html#usememo)]

Essentially, to keep things performant and properly manage memory, React may get rid of a cached value it's not actively using in order to save room for other operations. In this case, `useMemo` will have to recalculate its return value even if the values being passed to the hook have been used before.

### In practice

```javascript
// TODO: ADD CODE SAMPLE
```

<iframe
  src="https://codesandbox.io/embed/strange-thunder-kfgvu?fontsize=14&hidenavigation=1&theme=dark&view=editor"
  style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
  title="hooks/useMemo"
  allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb"
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
></iframe>
