---
title: "Hooks Revisited: useReducer"
date: "2020-05-18"
published: false
tags:
  - "react"
  - "hooks"
  - "javascript"
attachments:
---

### An update on state

Throughout this series, all of the code snippets and sandboxes we've created have used `useState` to manage our component data. However, React offers us an additional hook to use for storing data: `useReducer`.

While `useState` allows us to store and set a single value, `useReducer` helps us work with more complex or structured data by allows us to store and manipulate related values alongside one another.

### Anatomy of useReducer

Like `useState`, `useReducer` returns an array with two values:

1. The current state
2. A function that allows us to manipulate the state

```javascript
const [value, setValue] = useState(null)

const [state, dispatch] = useReducer(reducer, initialState)
```

The `useReduce` hook takes two arguments, with an [optional third](https://reactjs.org/docs/hooks-reference.html#specifying-the-initial-state).

The first argument is a reducer function, which defines the logic associated with each reducer action and the logic for updating state whenever a specific action is fired. We'll see an example of how this works in a moment.

Secondly, we pass the `useReducer` hook a value that represents it's initial state. This effectively works in the same way as the value you pass to the `useState` hook.

The third argument is an optional initialization function. According to the documentation:

> It lets you extract the logic for calculating the initial state outside the reducer. This is also handy for resetting the state later in response to an action. ~ [[React docs](https://reactjs.org/docs/hooks-reference.html#lazy-initialization)]

### Difference from useState

To best illustrate the difference in how `useReducer` and `useState` work, respectively, let's look at them side by side. The snippet below shows the code you'd need to use to instantiate and update a state value using both hooks:

```javascript
// useState
const [name, setName] = useState("")
setName("Ryan")
console.log(name) // 'Ryan'

// useReducer
const initialState = {
  name: "",
}

function reducer(state, action) {
  switch (action.type) {
    case "update-name":
      return {
        ...state,
        name: action.value,
      }
  }
}

const [state, dispatch] = useReducer(reducer, initialState)
dispatch({ type: "update-name", value: "Ryan" })
console.log(state.name) // 'Ryan'
```

While `useState`'s setter function updates it's value directly, `useReducer` dispatches an action. The reducer function (which is listening for these actions) the determins what type of action was fired and subsequently how to update its state. If you haven't used it in the past, this is pretty much exactly how [Redux](https://redux.js.org/) works.

### In practice

In the sandbox below, I've built a form for scheduling an appointment. Though there are multiple inputs with different types, all of the values are related to one another as they are in the same `<form>`.

<iframe
  src="https://codesandbox.io/embed/hooksusereducer-5rntg?fontsize=14&hidenavigation=1&theme=dark"
  style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
  title="hooks/useReducer"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

Instead of storing each input value in its own `useState` hook, we can store and manage all of the values in our form using a single `useReducer`. In this case, its state is an object with many keys, each representing an individual input's value. In fact, it's very similar to how `this.state` in `class` components.

We've defined our initial state as the following:

```javascript
const blankForm = {
  name: "",
  email: "",
  date: "",
  time: "",
  feeling: "3",
}

const [formState, dispatch] = useReducer(reducer, blankForm)
```

Each of the fields in the `blankForm` object represents and stores the value for the associated input in our form. Since the initial state of `email` is an empty string, the e-mail input will be blank on render since it reads its value from the `useReducer`'s state:

```javascript
<input
  className="Form__input"
  name="email"
  type="email"
  value={formState.email}
/>
```

To make this work, we've also set our inputs' `onChange` handlers to dispatch specific actions in order to update the state:

```javascript
<input
  className="Form__input"
  name="email"
  type="email"
  value={formState.email}
  onChange={event => {
    dispatch({ type: "setEmail", value: event.target.value })
  }}
/>
```

In the snippet above, we're specifically dispatching the `setEmail` action. Inside of the reducer, the `switch` statement looks at the `action.type` and determines what to do:

```javascript
function reducer(state, action) {
  switch (action.type) {
    case "setName":
      return {
        ...state,
        name: action.value,
      }
    case "setEmail":
      return {
        ...state,
        email: action.value,
      }
    case "setDate":
      return {
        ...state,
        date: action.value,
      }
    case "setTime":
      return {
        ...state,
        time: action.value,
      }
    case "setFeeling":
      return {
        ...state,
        feeling: action.value,
      }
    case "reset":
      return blankForm
  }
}
```

When `setEmail` is called, the reducer returns a new object that contains all of the current state information, except it updates `email` to whatever was dispatched as `action.value`.

Finally, since our hook's state has been updated, the component re-renders and the `<input />`s all read their updated value from `formState`.
